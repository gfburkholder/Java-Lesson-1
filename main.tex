\documentclass[14pt]{extreport}%
\usepackage[Conny]{fncychap}
\usepackage{amsfonts}
\usepackage{fancyhdr}
\usepackage[usenames, dvipsnames]{color}
\usepackage{comment}
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=2.2cm, right=2.2cm]%
{geometry}


\usepackage{titlesec}
\titleformat{\section}
{\color{Maroon}\normalfont\Large\bfseries}
{\color{Maroon}\thesection}{1em}{}[{\titlerule[0.8pt]}]

\renewcommand{\chaptername}{Unit}

\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
% Python environment
\lstnewenvironment{python}[1][]{\pythonstyle 
\lstset{#1}}{}
% Python for external files
\newcommand\pythonexternal[2][]{{\pythonstyle
\lstinputlisting[#1]{#2}}}
% Python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}


\titlespacing*{\chapter}{0pt}{-50pt}{40pt}

\begin{document}

% TITLE
% number following chapter should be (UNIT # - 1)
\setcounter{chapter}{0}
\chapter{\Large{\textbf{Lesson 1}: Intro to Java}}

% formatting parameter, don't change
\vspace{-10pt}

\section*{LEARNING OBJECTIVES}
\begin{itemize}
    \item fundamentals and syntax of Java \item basic programming concepts and data manipulation
    
\end{itemize}

\section*{KEY CONCEPTS}
\subsection*{Variables and Data Types}
\begin{itemize}
    \item Statically Typed Language
    \item int, float, boolean, char 
\end{itemize}

\subsection*{Control Flow }
\begin{itemize}
    \item conditionals and boolean logic 
    \item loops
\end{itemize}

\subsection*{Scope}
\begin{itemize}
    \item block scope
    

    
\end{itemize}
\subsection*{Arrays }
\begin{itemize}
    \item Arrays
    \item ArrayLists
\end{itemize}


    
\section*{Variables}     
\subsection*{Data Types in Java}
There are 8 primitive data types in Java, for now we will focus on 4:
\begin{enumerate}
    \item \textbf{int}
    \begin{enumerate}
        \item short for integer, which is any positive or negative whole number such as 8, 25, 0, -16, 100
    \end{enumerate}
    \item \textbf{float} 
    \begin{enumerate}
        \item floats are numbers with decimal points such as 4.3, -6.89, 15.0
    \end{enumerate}
    \item \textbf{boolean} 
    \begin{enumerate}
        \item booleans have only two possible values: \textbf{true} or \textbf{false}
    \end{enumerate}
    
    \item \textbf{char}
    \begin{enumerate}
        \item char is short for character are includes any character on your keyboard like "a", "x", "@". A bunch of characters together surrounded by quotation marks forms a \textbf{String} (another Data Type) such as "HelloWorld123"
    \end{enumerate}
\end{enumerate}


\subsection*{Declaring Variables in Java}
here are a couple examples of creating and assigning values to variables:
\begin{lstlisting}
//setting a variable equal to an integer
int myInt = 36;

//setting a variable equal to a float
float myFloat = 84.987;

//setting a variable equal to a boolean, unlike python true and false aren't capitalized
boolean myBool = true;

//setting a variable equal to a String
String myWord = "hello";
\end{lstlisting}

There are a few things going on here, first, notice the syntax; when declaring a variable the first thing you must tell the computer is what \textit{type} the variable is going to be, then you name the variable, and then you set it equal to the value you want it to refer to, and then finally you end the statement with a semicolon \textbf{;} (every statement must have a semicolon at the end).

\begin{lstlisting}
int x = "hello";
String y = 45;
\end{lstlisting}

Types are very important and strict in Java, the above code will not run because the declared type of the variable (on the left side) does not match the type of the value assigned on the right side

\begin{lstlisting}
int x = 58;
x = 4;
x = 78;
x = 34;
System.out.println(x);
\end{lstlisting}
Once you declare the type and value of a variable, you can change the value as many times as you want and you can omit the type declaration for each new assignement after the first one because the computer already knows what the type of the variable is. Also notice the syntax for printing the variable x at the end. What value do you think this will print?

\begin{lstlisting}
int x = 58;
x = "hello";
\end{lstlisting}

The code above will result in an error. Java is what is called a \textbf{Statically Typed Language} which means that the type of a variable cannot be changed after it is first declared. The code gives an error because we initially declared x to equal an int and then later tried to change the value of x to a String.
\section*{Boolean Logic }
Now that we know how to create and store data in variables, we want to know how we can actually use them in meaningful ways. This is where \textit{contol flow} comes in.

We have already seen that booleans can have only two values: \textit{true} or \textit{false}. When we combine these values with boolean operators like \textbf{and} / \textbf{or}, we get a single overall boolean value. \\* \\*
\textbf{\textit{Boolean operators syntax}}: 
\begin{lstlisting}
true && true // and operator
true || false // or operator
!true // not operator
\end{lstlisting}

\subsection*{Problem}
\begin{lstlisting}
boolean A = true;
boolean B = true;
boolean C = false;
boolean D = true;
boolean E = false;
int outside_temp = 32;
int freezing_point = 32;
int body_temp = 97;
int coffee_temp = 120;

System.out.println(A && B);  //Q1
System.out.println((A || E) && D);  //Q2
System.out.println(A || B || D || C);  //Q3
System.out.println(A && B && D && C);  //Q4
System.out.println(outside_temp <= freezing_point);  //Q5
System.out.println(( coffee_temp > body_temp ) && E);  //Q6
\end{lstlisting}

\subsection*{Solution}
\textbf{Q1. True}. (A and B) is the same as (True and True). \\*
\textbf{Q2. True}. (A or E) evaluates to True, so we are left with (True or True). \\*
\textbf{Q3. True}. We only need one of these to be True for the whole logical statement to be True. \\*
\textbf{Q4. False}. We need all of these to be True for the whole logical statement to be True. Since C is false, the result is False. \\*
\textbf{Q5. True}. Remember that comparison operators also give a Boolean value
once they have been evaluated. 32 is less than or equal to 32. \\*
\textbf{Q6. False}. While coffee temp is greater than body temp, E is false. (True
and False) evaluates to False. \\* \\* \\*

\section*{Conditionals }
Now that we now how to evaluate boolean statements, we can use these statements to control on the computer moves through a program and to tell it to only execute certain blocks of code if some condition is met.

\subsection*{if statements}
Lets say we have a program that allows us to change how many cookies we have. We then want to increase that number by 5 and then tell us how
many we will have at the end.

\begin{lstlisting}
int cookies = 50;
cookies += 5;
System.out.println("Total cookies: " + Integer.toString(cookies));
\end{lstlisting} 
But what if they already have enough cookies? We don't have to give them
any more so that we have more to share with others. 10 sounds like it'll be
enough. So, if they have more than 10 cookies, we won't give them anymore.
Its pretty easy to translate this idea to code:
\begin{lstlisting}
int cookies = 50;

if (cookies <= 10){
  cookies += 5;
}

System.out.println("Total cookies: " + Integer.toString(cookies));
\end{lstlisting}
Here, we used an if statement to determine whether or not to give more cookies. Notice the syntax:
\begin{lstlisting}
if ( condition ){
   code to be executed when condition is met;
}
\end{lstlisting}
The keyword \textbf{if} is followed by parentheses containing a condition (that is either true or false), if that condition is true, then the code inside of the if statement is executed. Notice how we don't need a semicolon at the end of the \textit{if (condition) } statement, instead, we use a curly bracket to denote the start of the if block and another curly bracket to denote the end of the if statement. Unlike in python, the whitespace indentation is unnecessary, the curly brackets tell the computer what is inside the if block, but for the sake of readability, it is good practice to still indent whatever is inside the if block.

\subsection*{else if statements}
Our cookie program only takes one condition into account: if they have more
than 10 cookies. Another case is if they have too many, say more than 1000?
If this is true, well take away 100 so there's more for everyone!

\begin{lstlisting}
int cookies = 5000;

if (cookies <= 10){
  cookies += 5;
}

else if (cookies >= 1000){
  cookies -= 100;
}

System.out.println("Total cookies: " + Integer.toString(cookies));
\end{lstlisting}{}
Reading this code
block in English, it sounds like: if the number of cookies is less than or equal
to 10, increment by 10. Otherwise, if the number of cookies is greater than or equal
to 1000, subtract 100. Always print the total number of cookies.

\subsection*{else statements}
Finally, you may have noticed that our program does not account for all cases. We only look at times when they have under 10 or over 1000 cookies. Fortunately, Python (and many other programming languages) have a catch-all sort of statement, called else. This line will execute if and only if none of the above conditionals are evaluated to True. Lets say that in our program, we want to give 10 cookies if we execute the else block.

\begin{lstlisting}
int cookies = 100;

if (cookies <= 10){
  cookies += 5;
}

else if (cookies >= 1000){
  cookies -= 100;
}

else{
  cookies += 10;
}

System.out.println("Total cookies: " + Integer.toString(cookies));
\end{lstlisting}{}

So, if the top two conditions fail, we reach the else statement. Reading this code block in English, it sounds like: if the number of cookies is less than or equal to 10, increment by 10. Else, if the number of cookies is greater than or equal to 1000, subtract 100. Else, add 10. Always print the total number of cookies.

\subsection*{structuring if and else if blocks}
It is important to be able to distinguish between the following code blocks:
\begin{lstlisting}
int cookies = 1100;

if (cookies >= 10){
  cookies += 5;
}

else if (cookies >= 1000){
  cookies -= 100;
}

System.out.println("Total cookies: " + Integer.toString(cookies));
\end{lstlisting}{}

\begin{lstlisting}
int cookies = 1100;

if (cookies >= 10){
  cookies += 5;
}

if (cookies >= 1000){
  cookies -= 100;
}

System.out.println("Total cookies: " + Integer.toString(cookies));
\end{lstlisting}{}

Lets assume that cookies = 1100. In the top block of code, both the if and else if conditions are met, but only the first executes because the else if is reached only if the first if statement fails. At the end of the top block of code, cookies = 1105. However, in the bottom code block, both
conditions are again met, and both mathematical operations (plus 5, minus
100) are executed because the if statements are read in order. At the end of
the top block of code, cookies = 1005. The computer doesn't know
that the two if statements are related.
\section*{Loops}
Up until this point, we have only seen programs where each line of code is read sequentially and is executed only once, so how do we get the computer to execute the same task multiple times without having to write the same code over and over again? This is where loops come in. There are two kinds of loops, \textbf{For loops} and \textbf{While loops}

\subsection*{For loops }
A for loop is a block of code that executes a given number of times. Here is a basic example of what a for loop in java looks like:

\begin{lstlisting}
for (int i = 0; i<10; i++){
    System.out.println(i);
}
\end{lstlisting}{}
the for loop takes in 3 parameters: the first one is where we declare the index variable (and make sure it has a declared type) and set it equal to whatever starting number we want. The second parameter specifies that point at which the loop will stop executing, in this case, once i equals 10 the loop will terminate (it continues to execute so long as i is less than 10). Finally, the third parameter specifies the amount that we wish to increment the index variable by, in this example we increment i by 1 after each iteration of the loop.
\begin{lstlisting}
0
1
2
3
4
5
6
7
8
9
\end{lstlisting}{}
this is what the for loop prints, notice how it includes the initial value of i (0) but not 10 (since we told it to execute while i is less than 10, not less than \textit{or equal} to 10. As we will see in a future section, we can also use for loops to \textit{iterate} through data structures like lists. \\*

\subsection*{While loops}
here is an example of a basic while loop:
\begin{lstlisting}
int i = 0;
while (i < 10){
    System.out.println(i);
    i++;
}
\end{lstlisting}{}
At first glance you might think that this is essentially the exact same thing as the for loop we just saw, and you would be right, it starts out by declaring and initializing the variable i, it provides a condition that must be met for the loop to keep executing, and it provides an increment that will ensure that i is eventually not less than 10, all just like the for loop did, it will even print out the exact same values as our for loop did! So then what do we even need while loops for?
\begin{lstlisting}
boolean hasWon = false;
    int score = 0;

    while (!hasWon){
        if (hit){
            score += 10;
        }
        else if (miss){
            score -= 5;
        }
        if (score == 100){
            hasWon = true;
        }
    }
\end{lstlisting}{}
The pseudocode above is an example of when a for loop wouldn't work for what we are trying to achieve. Say we have a simple game where a player throws balls at a target; if she hits the target, she gets 10 points added to her score, and if she misses, she subtracts 5 points from her score, and once she gets 100 points, the game is over! It could take her a minimum of 10 throws to win the game but at the most it could take her an infinite number of throws to finally reach 100 points! Because we don't know exactly how many throws she will need in order to reach 100 points, we can't use a for loop that has a set range of how many times it executes, instead, we need a while loop that keeps on executing as many times as needed until 100 points are achieved. \\*

\subsection*{infinite loops}
Something that we must be careful of when using loops (particularly while loops) is that they can easily loop forever and ever on accident! See if you can determine why the code below will result in an infinite loop and how they can be fixed:
\subsubsection{\textit{Problem \#1}}

\begin{lstlisting}
int num = 10;

while (num > 0){
    
    System.out.println(num);
    num++;
    
}
\end{lstlisting}{}

\subsubsection{\textit{Problem \#2}}
\begin{lstlisting}
boolean hasWon = false;
int score = 0;

while (!hasWon){
        
    if (hit){
        score += 10;
    }
    else if (miss){
        score -= 5;
    }

}
\end{lstlisting}{}

\subsubsection{\textit{Solution \#1}}
This while loop will execute forever because the condition num > 0 will never be false! This is because we are \textit{incrementing} i when we should be \textit{decrementing} i. i will keep on increasing by 1 and will never be less than 0.

\subsubsection{\textit{Solution \#2}}
This loop will never end because we never change the boolean variable \textit{hasWon} to false when the player's score reaches 100! Go back to to code example in the previous section to see the correct code.

\section*{Scope}
The \textit{Scope} of a variable is the regions of code from which a variable can be referenced. In other words, it is where you can use a variable without getting an error message. We have seen, with both conditionals and loops, that some code can be located inside \textit{blocks}. If we declare a variable within a block, then it cannot be used from anywhere outside of that block. The code below illustrates this:
\begin{lstlisting}
int num = 10;


if (num == 10){

    int localBlockVariable = 200;
    
}

System.out.println(localBlockVariable);
    
\end{lstlisting}{}
The print statement will result in an error, saying that the computer cannot find the variable called localBlockVariable, because we are trying to use the variable outside of the block that it was declared in.
\begin{lstlisting}
int num = 10;
int globalVariable = 200;

if (num == 10){

    globalVariable += 50;
    
}

System.out.println(globalVariable);
\end{lstlisting}{}
In the code above, notice how instead of declaring our variable inside of the if block, we declare at the outermost level of the program, so now the print statment will not result in an error because it is referencing a variable within its scope. Also notice how we can reference the variable from inside the if block. Variables can be referenced from regions of the code that is narrower than the scope of the variable itself.

\section*{Arrays}
An array stores a sequence of elements. An array is a data structure that
holds a \textbf{fixed number} of values of a single type. The values are stored next
to each other in memory, and can be accessed with the same variable name. 
\subsection*{Creating an array}
\begin{lstlisting}
// declares an array of integers
int[] anArray;
// allocates memory for 5 integers
anArray = new int[5];
\end{lstlisting}{}
here is the syntax for creating a new empty array in Java, it can now hold no more than 5 integers.
\begin{lstlisting}
// initialize first element
anArray[0] = 100;
// initialize second element
anArray[1] = 200;
// and so forth
anArray[2] = 300;
anArray[3] = 400;
anArray[4] = 500;
System.out.println("Element at index 0: " + anArray[0]);
System.out.println("Element at index 1: " + anArray[1]);
System.out.println("Element at index 2: " + anArray[2]);
System.out.println("Element at index 3: " + anArray[3]);
System.out.println("Element at index 4: " + anArray[4]);
/*
Element at index 0: 100
Element at index 1: 200
Element at index 2: 300
Element at index 3: 400
Element at index 4: 500
*/
\end{lstlisting}{}
The code above shows how we add values to the array and then how to get each value from the array. Notice how the indexing starts at 0 instead of 1, so the first value in the array is at index 0, the second value in the array is at index 1. 

\subsection*{Iterating through arrays}
An extremely useful thing to do is to loop through and retrieve every value in an array to be used one at a time. There are a coupe of ways that this can be achieved in Java:
\begin{lstlisting}

// looping using normal for loop
int[] primes = {2, 3, 5, 7, 11, 13, 17}; 
 
for(int i=0; i< primes.length; i++){ 
    System.out.println("current element is: " + primes[i]); 
}

//output
current element is: 2 
current element is: 3 
current element is: 5 
current element is: 7 
current element is: 11 
current element is: 13 
current element is: 17
\end{lstlisting}{}
This approach uses the normal for loop we saw in a previous section where you give it the starting number (0) and then increment that number by 1 until it is more than the length of the array. At every iteration, this number is used to index into the array and get the element at that number. Here is another way to do it:
\begin{lstlisting}
// looping using enhanced for loop of Java 5 
for(int number: primes){ 

    System.out.println(number); 
    
}
\end{lstlisting}{}
This is a much more direct and simpler way of iterating through and returning every value in an array.

\subsection*{Multidimensional Arrays}
In Java, a multidimensional array is an array whose elements are themselves
arrays. This allows rows to vary in length. Think of this like a table, although
the size of rows do not have to match. Another example is to consider a
kitchen drawer which has compartments inside that hold different utensils
- for multidimensional arrays, the outer array is the drawer itself, and the
elements of the array are the compartments of utensils.
\begin{lstlisting}
// declares an array of integers
String[][] names = {
    {"Mr. ", "Mrs. ", "Ms. "},
    {"Smith", "Jones"}
};
System.out.println(names[0][0] + names[1][0]);
System.out.println(names[0][2] + names[1][1]);
/*
Mr. Smith
Ms. Jones
*/
\end{lstlisting}{}
Take note that the indexing of multidimensional arrays is [row][column].
Not all programming languages allow multidimensional arrays to have differ-
ent length rows.
\section*{ACTIVITY \#1} 
\subsection*{Problem}
Description of problem.
\subsection*{Solution}
Description of solution.\\
\begin{python}
#put python code here

\end{python}

\section*{ACTIVITY \#2} 
\subsection*{Problem}
Description of problem.

\subsection*{Solution}
Description of solution.\\
\begin{python}
#put python code here
\end{python}

\section*{ACTIVITY \#3} 
\subsection*{Problem}
Description of problem.
\subsection*{Solution}
Description of solution. \\
\begin{python}
#put python code here
\end{python}

\section*{ADDITIONAL PRACTICE} 
\subsection*{Problem}
Description of problem.
\subsection*{Solution}
Description of solution. \\
\begin{python}
#put python code here
\end{python}

\section*{MORE ADVANCED PRACTICE} 
\subsection*{Problem}
Description of problem.
\subsection*{Solution}
Description of solution. \\
\begin{python}
#put python code here
\end{python}

\section*{RESOURCES}
\begin{itemize}
    \item Resource 1
    \item Resource 2
\end{itemize}

\section*{CHECK-IN}
\begin{enumerate}
    \item Question 1
    \item Question 2
\end{enumerate}

\section*{HOMEWORK}

\end{document}
